-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParLang where
import AbsLang
import LexLang
import ErrM

}

%name pModule Module
%name pValue Value
%name pListValue ListValue
%name pDecl Decl
%name pListDecl ListDecl
%name pModel Model
%name pRecipe Recipe
%name pListRecipe ListRecipe
%name pLayer Layer
%name pListLayer ListLayer
%name pIngredient Ingredient
%name pHyperParams HyperParams
%name pListHyperParam ListHyperParam
%name pHyperParam HyperParam
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  ',' { PT _ (TS _ 1) }
  ':=' { PT _ (TS _ 2) }
  '[' { PT _ (TS _ 3) }
  ']' { PT _ (TS _ 4) }
  'batch_normalize' { PT _ (TS _ 5) }
  'conv' { PT _ (TS _ 6) }
  'model' { PT _ (TS _ 7) }
  'recipe' { PT _ (TS _ 8) }
  'relu' { PT _ (TS _ 9) }
  'strides' { PT _ (TS _ 10) }
  '{' { PT _ (TS _ 11) }
  '}' { PT _ (TS _ 12) }
  L_integ  { PT _ (TI $$) }
  L_ident  { PT _ (TV $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Ident   :: { Ident }
Ident    : L_ident  { Ident $1 }

Module :: { Module }
Module : ListDecl { AbsLang.M (reverse $1) }
Value :: { Value }
Value : Integer { AbsLang.ValueInt $1 }
ListValue :: { [Value] }
ListValue : {- empty -} { [] }
          | Value { (:[]) $1 }
          | Value ',' ListValue { (:) $1 $3 }
Decl :: { Decl }
Decl : Model { AbsLang.ModDecl $1 } | Recipe { AbsLang.RecDecl $1 }
ListDecl :: { [Decl] }
ListDecl : {- empty -} { [] } | ListDecl Decl { flip (:) $1 $2 }
Model :: { Model }
Model : 'model' Ident '{' ListLayer '}' { AbsLang.Mod $2 (reverse $4) }
Recipe :: { Recipe }
Recipe : 'recipe' Ident '{' ListLayer '}' { AbsLang.R $2 (reverse $4) }
ListRecipe :: { [Recipe] }
ListRecipe : {- empty -} { [] }
           | ListRecipe Recipe { flip (:) $1 $2 }
Layer :: { Layer }
Layer : Ingredient HyperParams { AbsLang.Op $1 $2 }
      | Ident { AbsLang.NamedRecipe $1 }
ListLayer :: { [Layer] }
ListLayer : {- empty -} { [] } | ListLayer Layer { flip (:) $1 $2 }
Ingredient :: { Ingredient }
Ingredient : 'relu' { AbsLang.Relu }
           | 'conv' { AbsLang.Conv }
           | 'batch_normalize' { AbsLang.BatchNorm }
HyperParams :: { HyperParams }
HyperParams : '[' ListHyperParam ']' { AbsLang.Hyps $2 }
ListHyperParam :: { [HyperParam] }
ListHyperParam : {- empty -} { [] }
               | HyperParam ListHyperParam { (:) $1 $2 }
               | {- empty -} { [] }
               | HyperParam { (:[]) $1 }
               | HyperParam ',' ListHyperParam { (:) $1 $3 }
HyperParam :: { HyperParam }
HyperParam : 'strides' ':=' '[' ListValue ']' { AbsLang.Stride $4 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

