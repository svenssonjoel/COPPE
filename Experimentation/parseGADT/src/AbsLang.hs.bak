{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
module AbsLang (Tree(..), Module, Value, Decl, Model, Recipe, Layer, Ingredient, HyperParams, HyperParam, Ident, johnMajorEq, module ComposOp) where

import ComposOp

import Data.Monoid (mappend)


-- Haskell module generated by the BNF converter

data Tag = Module_ | Value_ | Decl_ | Model_ | Recipe_ | Layer_ | Ingredient_ | HyperParams_ | HyperParam_ | Ident_
type Module = Tree Module_
type Value = Tree Value_
type Decl = Tree Decl_
type Model = Tree Model_
type Recipe = Tree Recipe_
type Layer = Tree Layer_
type Ingredient = Tree Ingredient_
type HyperParams = Tree HyperParams_
type HyperParam = Tree HyperParam_
type Ident = Tree Ident_

data Tree :: Tag -> * where
    M :: [Decl] -> Tree Module_
    ValueInt :: Integer -> Tree Value_
    ModDecl :: Model -> Tree Decl_
    RecDecl :: Recipe -> Tree Decl_
    Mod :: Ident -> [Layer] -> Tree Model_
    R :: Ident -> [Layer] -> Tree Recipe_
    Op :: Ingredient -> HyperParams -> Tree Layer_
    NamedRecipe :: Ident -> Tree Layer_
    Relu :: Tree Ingredient_
    Conv :: Tree Ingredient_
    Hyps :: [HyperParam] -> Tree HyperParams_
    Stride :: [Value] -> Tree HyperParam_
    Ident :: String -> Tree Ident_

instance Compos Tree where
  compos r a f t = case t of
      M decls -> r M `a` foldr (\ x z -> r (:) `a` f x `a` z) (r []) decls
      ModDecl model -> r ModDecl `a` f model
      RecDecl recipe -> r RecDecl `a` f recipe
      Mod ident layers -> r Mod `a` f ident `a` foldr (\ x z -> r (:) `a` f x `a` z) (r []) layers
      R ident layers -> r R `a` f ident `a` foldr (\ x z -> r (:) `a` f x `a` z) (r []) layers
      Op ingredient hyperparams -> r Op `a` f ingredient `a` f hyperparams
      NamedRecipe ident -> r NamedRecipe `a` f ident
      Hyps hyperparams -> r Hyps `a` foldr (\ x z -> r (:) `a` f x `a` z) (r []) hyperparams
      Stride values -> r Stride `a` foldr (\ x z -> r (:) `a` f x `a` z) (r []) values
      _ -> r t

instance Show (Tree c) where
  showsPrec n t = case t of
    M decls -> opar n . showString "M" . showChar ' ' . showsPrec 1 decls . cpar n
    ValueInt integer -> opar n . showString "ValueInt" . showChar ' ' . showsPrec 1 integer . cpar n
    ModDecl model -> opar n . showString "ModDecl" . showChar ' ' . showsPrec 1 model . cpar n
    RecDecl recipe -> opar n . showString "RecDecl" . showChar ' ' . showsPrec 1 recipe . cpar n
    Mod ident layers -> opar n . showString "Mod" . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 layers . cpar n
    R ident layers -> opar n . showString "R" . showChar ' ' . showsPrec 1 ident . showChar ' ' . showsPrec 1 layers . cpar n
    Op ingredient hyperparams -> opar n . showString "Op" . showChar ' ' . showsPrec 1 ingredient . showChar ' ' . showsPrec 1 hyperparams . cpar n
    NamedRecipe ident -> opar n . showString "NamedRecipe" . showChar ' ' . showsPrec 1 ident . cpar n
    Relu -> showString "Relu"
    Conv -> showString "Conv"
    Hyps hyperparams -> opar n . showString "Hyps" . showChar ' ' . showsPrec 1 hyperparams . cpar n
    Stride values -> opar n . showString "Stride" . showChar ' ' . showsPrec 1 values . cpar n
    Ident str -> opar n . showString "Ident" . showChar ' ' . showsPrec 1 str . cpar n
   where opar n = if n > 0 then showChar '(' else id
         cpar n = if n > 0 then showChar ')' else id

instance Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> Bool
johnMajorEq (M decls) (M decls_) = decls == decls_
johnMajorEq (ValueInt integer) (ValueInt integer_) = integer == integer_
johnMajorEq (ModDecl model) (ModDecl model_) = model == model_
johnMajorEq (RecDecl recipe) (RecDecl recipe_) = recipe == recipe_
johnMajorEq (Mod ident layers) (Mod ident_ layers_) = ident == ident_ && layers == layers_
johnMajorEq (R ident layers) (R ident_ layers_) = ident == ident_ && layers == layers_
johnMajorEq (Op ingredient hyperparams) (Op ingredient_ hyperparams_) = ingredient == ingredient_ && hyperparams == hyperparams_
johnMajorEq (NamedRecipe ident) (NamedRecipe ident_) = ident == ident_
johnMajorEq Relu Relu = True
johnMajorEq Conv Conv = True
johnMajorEq (Hyps hyperparams) (Hyps hyperparams_) = hyperparams == hyperparams_
johnMajorEq (Stride values) (Stride values_) = values == values_
johnMajorEq (Ident str) (Ident str_) = str == str_
johnMajorEq _ _ = False

instance Ord (Tree c) where
  compare x y = compare (index x) (index y) `mappend` compareSame x y
index :: Tree c -> Int
index (M _) = 0
index (ValueInt _) = 1
index (ModDecl _) = 2
index (RecDecl _) = 3
index (Mod _ _) = 4
index (R _ _) = 5
index (Op _ _) = 6
index (NamedRecipe _) = 7
index (Relu ) = 8
index (Conv ) = 9
index (Hyps _) = 10
index (Stride _) = 11
index (Ident _) = 12
compareSame :: Tree c -> Tree c -> Ordering
compareSame (M decls) (M decls_) = compare decls decls_
compareSame (ValueInt integer) (ValueInt integer_) = compare integer integer_
compareSame (ModDecl model) (ModDecl model_) = compare model model_
compareSame (RecDecl recipe) (RecDecl recipe_) = compare recipe recipe_
compareSame (Mod ident layers) (Mod ident_ layers_) = mappend (compare ident ident_) (compare layers layers_)
compareSame (R ident layers) (R ident_ layers_) = mappend (compare ident ident_) (compare layers layers_)
compareSame (Op ingredient hyperparams) (Op ingredient_ hyperparams_) = mappend (compare ingredient ingredient_) (compare hyperparams hyperparams_)
compareSame (NamedRecipe ident) (NamedRecipe ident_) = compare ident ident_
compareSame Relu Relu = EQ
compareSame Conv Conv = EQ
compareSame (Hyps hyperparams) (Hyps hyperparams_) = compare hyperparams hyperparams_
compareSame (Stride values) (Stride values_) = compare values values_
compareSame (Ident str) (Ident str_) = compare str str_
compareSame x y = error "BNFC error:" compareSame
